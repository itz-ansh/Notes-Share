1) Constants:- 

A constant is an entity that doesn’t change whereas a variable is an entity that may change.


**Types of C Contants**

a) Primary Constants

    i) Integer Constants
    ii) Real Constants
    iii) Character Constants


b) Secondary Constants

   i) Array
   ii) Pointer
   iii) Structure
   iv) Union
   v) Enum, etc



--> **Rules for Constructing Integer Constants**

a) An integer constant must have at least one digit.
b) It must not have a decimal point.
c) It can be either positive or negative.
d) If no sign precedes an integer constant it is assumed to be
   positive.
e) No commas or blanks are allowed within an integer constant.
f) The allowable range for integer constants is -32768 to 32767.

Truly speaking the range of an Integer constant depends upon the
compiler. For a 16-bit compiler like Turbo C or Turbo C++ the
range is –32768 to 32767. For a 32-bit compiler the range would
be even greater. Question like what exactly do you mean by a 16-
bit or a 32-bit compiler, what range of an Integer constant has to
do with the type of compiler and such questions are discussed in
detail in Chapter 16. Till that time it would be assumed that we are
working with a 16-bit compiler.

Ex.: 426, +782, -8000, -7605  



--> **Rules for Constructing Real Constants**

Real constants are often called Floating Point constants. The real
constants could be written in two forms—Fractional form and
Exponential form.
Following rules must be observed while constructing real
constants expressed in fractional form:
a) A real constant must have at least one digit.
b) It must have a decimal point.
c) It could be either positive or negative.
d) Default sign is positive.
e) No commas or blanks are allowed within a real constant.

Ex.: +325.34, 426.0, -32.76, -48.5792

**NOTE**
In C programming, you can represent real constants (floating-point numbers) using exponential notation (also known as scientific notation). This allows large or small numbers to be represented in a compact form.

The exponential form consists of two parts:

--> Mantissa: This is the base number that appears before the e.

--> Exponent: This is the power of 10 that the base number is multiplied by, and it appears after the e.
The general format is:

a) mantissa is a floating-point number (with or without a decimal point).
b) e is the letter that indicates exponential notation (can be lowercase or uppercase).
exponent is an integer that indicates the power of 10.

Example:

float value = 1.23e4;
This can be interpreted as:

Mantissa: 1.23
Exponent: 4

This means that the number is 1.23 * 10^4, which is 12300.0.

--> Key Points:-

You can use either e or E in the representation, and both are valid in C.
The exponent can be positive or negative. A positive exponent shifts the decimal point to the right, while a negative exponent shifts it to the left.

Example:

int main() 
{
    float num1 = 3.5e2;   // 3.5 * 10^2 = 350
    float num2 = 4.1e-3;  // 4.1 * 10^-3 = 0.0041

    printf("num1 = %f\n", num1);  // Output: 350.000000
    printf("num2 = %f\n", num2);  // Output: 0.004100

    return 0;
}

In this code:

num1 = 3.5e2 represents 3.5 * 10^2, which equals 350.0.
num2 = 4.1e-3 represents 4.1 * 10^-3, which equals 0.0041.

--> Practical Use:
Exponential notation is useful for representing very large numbers (like the speed of light: 3e8 meters/second) or very small numbers (like the charge of an electron: 1.6e-19 coulombs) in a concise form.



--> **Rules for Constructing Character Constants**

a) A character constant is a single alphabet, a single digit or a
single special symbol enclosed within single inverted
commas. Both the inverted commas should point to the left.
For example, ’A’ is a valid character constant whereas ‘A’ is
not.
b) The maximum length of a character constant can be 1
character.
Ex.: 'A', 'I', '5', '=' 





2) Variables:- 

Variables are used to store data values that can be manipulated during the execution of a program. A variable has a name (called an identifier) and a data type, which determines what kind of data it can hold. Basically, an entity that may vary during program execution is called a variable.
For example, a variable can hold integer numbers, floating-point numbers, or characters.


**Types of Variables**

a) int: Stores integers (whole numbers).
b) float: Stores floating-point (decimal) numbers.
c) char: Stores a single character.
d) double: Stores double-precision floating-point numbers.
e) other types: You also have arrays, pointers, structures, etc.


--> **Rules for Constructing Variable Names**

a) A variable name is any combination of 1 to 31 alphabets,
digits or underscores. Some compilers allow variable names
whose length could be up to 247 characters. Still, it would be
safer to stick to the rule of 31 characters. Do not create
unnecessarily long variable names as it adds to your typing
effort.
b) The first character in the variable name must be an alphabet or
   underscore.
c) No commas or blanks are allowed within a variable name.
d) No special symbol other than an underscore (as in gross_sal)
   can be used in a variable name.

Ex.: si_int, m_hra, pop_e_89

These rules remain same for all the types of primary and secondary
variables.


--> Naturally, the question follows... how is C able to
differentiate between these variables? This is a rather simple matter. 
C compiler is able to distinguish between the variable names by making 
it compulsory for you to declare the type of any variable name that you wish 
to use in a program. This type declaration is done at the beginning of the program. 
Following are the examples of type declaration statements:

Ex.: int si, m_hra ;
     float bassal ;
     char code ; 


**Key Points about Variables in C**

a) Declaration: Before using a variable, you must declare it by specifying its data type and name. 
For example:

int number;  // Declares an integer variable named 'number'

b) Initialization: You can also initialize a variable at the time of declaration, which means assigning an initial value to it. For example:

int number = 10;  // Declares and initializes 'number' with a value of 10

More examples:-

    main()
    {
        int a = 1;  //Declared and Initialized variable a
        float b = 2.5;  //Declared and Initialized variable b
        char c = 'x';  //Declared and Initialized variable c

        printf("a = %d", a);
        printf("\nb = %f", b);
        printf("\nc = %c", c);
    }

Output:-
        a = 1
        b = 2.500000
        c = x





3) Keywords:- 

a) The keywords are also called 'Reserved words'.
b) Keywords are the words whose meaning has already been
   explained to the C compiler (or in a broad sense to the computer).
c) The keywords cannot be used as variable names because if we do
   so we are trying to assign a new meaning to the keyword, which is
   not allowed by the computer.
d) There are only 32 keywords available in C:-

        auto    double      int       struct
        break    else       long      switch
        case     enum     register    typedef
        char    extern     return     union
        const   float      short     unsigned
      continue   for       signed      void
       default   goto      sizeof    volatile
         do       if       static      while 





**Note**
Difference between *return* and *exit*
(https://chatgpt.com/share/670d0c1d-2794-800a-b374-5ee2c4b2ecf2)

exit: In C, exit is a library function (not a keyword) that is used to terminate a program. It is part of the <stdlib.h> header file, and its purpose is to exit a program and return a status code to the operating system, indicating whether the program executed successfully or encountered an error.

--> Difference between exit and return:-

Both exit() and return can be used to terminate a program, but they behave differently:

a) return exits from the current function (usually main()), while exit() immediately terminates the whole program regardless of where it is called.
b) When you use return in main(), the return value is treated as the exit status of the program. In this sense, return in main() can be viewed as similar to exit().

In summary:

* exit() terminates the entire program immediately, regardless of where it is called.

* return only returns from the current function and allows other parts of the program (like remaining function calls) to continue execution.

--> Exit Status:-

a) A status of 0 indicates successful termination (conventionally).

Example with Success Status:

#include <stdio.h>
#include <stdlib.h>

int main() 
{
    printf("Exiting program.\n");
    exit(0);  // Exiting the program with a success status

    printf("This will not be printed.\n");  // This will never execute
    return 0;
}


b) A non-zero status (e.g., exit(1)) usually indicates an error or abnormal termination.

Example with Error Status:

#include <stdio.h>
#include <stdlib.h>

int main() 
{
    if (1 == 1) 
    {
        printf("An error occurred!\n");
        exit(1);  // Exit with an error status
    }

    printf("This will not be printed.\n");
    return 0;
}

In this case, the program prints "An error occurred!" and exits with status 1, indicating an error.


--> If you use exit() inside any function, it immediately terminates the entire program, and no other functions will be called after that, regardless of their position in the code.

When exit() is called, the control is never returned to the calling function or any other part of the program. This means that even if other functions are still pending or supposed to be executed, they will not be executed. The program stops right where exit() is invoked.


i) Example:
Let’s see what happens when exit() is used inside a function.

#include <stdio.h>
#include <stdlib.h>

void func1() {
    printf("Inside func1.\n");
    exit(0);  // Program will terminate here, no other function will be executed
}

void func2() {
    printf("Inside func2.\n");
}

int main() {
    printf("Inside main function.\n");
    func1();  // Calling func1, which contains exit()
    func2();  // This function call will not execute because exit() is called in func1
    printf("End of main.\n");  // This will also not be executed
    return 0;
}

Output:

Inside main function.
Inside func1.

Explanation: 

In this program:
a) main() first prints "Inside main function."
b) Then, func1() is called, which prints "Inside func1." and then calls exit(0).
c) As soon as exit(0) is called inside func1(), the program terminates.
d) Therefore, func2() is never called, and the statement "End of main." is never printed because the program stops immediately after exit().

Key Points:-

1) exit() stops the entire program wherever it is called, not just the current function. This means that even if there are other functions or code blocks waiting to be executed, they will be skipped.

2) If you want a function to return to the caller (so other functions can continue executing), you should use return, not exit().


ii) Example with return instead of exit():-

#include <stdio.h>

void func1() 
{
    printf("Inside func1.\n");
    return;  // Returning from func1 (does not terminate the program)
}

void func2() 
{
    printf("Inside func2.\n");
}

int main() 
{
    printf("Inside main function.\n");
    func1();  // Calling func1
    func2();  // func2 will still be called
    printf("End of main.\n");  // This will be printed
    return 0;
}

Output:

Inside main function.
Inside func1.
Inside func2.
End of main.

Explanation: 

In this program, func1() uses return instead of exit(), so after func1() finishes executing, the program returns to main(), continues to call func2(), and then prints "End of main." at the end.


**In summary**-->
a) exit() terminates the entire program immediately, regardless of where it is called.
b) return only returns from the current function and allows other parts of the program (like remaining function calls) to continue execution.







